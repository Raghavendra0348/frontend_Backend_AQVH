how to run:
1.start the flask backend:
     source ~/Documents/quantum_dashboard/venv/bin/activate          
     cd ~/Documents/quantum_dashboard
     python app.py

2.opening frontend:
     cd Documents/quantum_dashboard/templates
     python3 -m http.server 8000
     Open any browser:
          http://localhost:8000
          
  <span> âž• Create Job</span>
              <!-- Circuit Controls -->
            <div class="bg-gray-50 rounded-xl p-6 mb-6">
                <div class="flex flex-wrap items-center gap-4">
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-700">Qubits:</label>
                        <input id="circuitQubits" type="number" min="1" max="8" value="3" class="w-20 px-3 py-2 border border-gray-300 rounded-lg text-sm text-black">
                    </div>
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-700">Shots:</label>
                        <input id="circuitShots" type="number" min="1" value="1024" class="w-24 px-3 py-2 border border-gray-300 rounded-lg text-sm text-black">
                    </div>
                    <div class="flex items-center space-x-2">
                        <label class="text-sm font-medium text-gray-700">Backend:</label>
                        <select id="circuitBackend" class="px-3 py-2 border border-black-300 rounded-lg text-sm text-black">
                            <option>Loading...</option>
                        </select>
                    </div>
                    <div class="flex space-x-2 ml-auto">
                        <button id="clearCircuit" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium transition-colors">
                            Clear Circuit
                        </button>
                        <button id="runCircuit" class="px-4 py-2 bg-gray-800 hover:bg-gray-900 text-white rounded-lg text-sm font-medium transition-colors">
                            Run Circuit
                        </button>
                    </div>
                </div>
            </div>
  
  
  
  
  
  
  
  
  
          from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import sqlite3
import json
import threading
import time
import random
from datetime import datetime
import base64
import io
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
import numpy as np
import os

app = Flask(__name__)
CORS(app, origins="*")
socketio = SocketIO(app, cors_allowed_origins="*")

# Database configuration - Using SQLite for easier setup
DATABASE_PATH = 'quantum_jobs.db'
db_lock = threading.Lock()  # Define db_lock for serializing database writes

def get_db_connection():
    try:
        connection = sqlite3.connect(DATABASE_PATH, check_same_thread=False, timeout=10)
        connection.row_factory = sqlite3.Row
        connection.execute("PRAGMA busy_timeout = 10000")  # 10 seconds in milliseconds
        return connection
    except Exception as e:
        print(f"Database connection error: {e}")
        return None

def init_database():
    try:
        connection = get_db_connection()
        if connection:
            cursor = connection.cursor()
            
            # Create table if it doesn't exist
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS jobs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    job_id TEXT UNIQUE NOT NULL,
                    status TEXT DEFAULT 'Queued' CHECK(status IN ('Queued', 'Running', 'Completed', 'Error', 'Cancelled')),
                    job_type TEXT NOT NULL,
                    backend TEXT NOT NULL,
                    qubits INTEGER NOT NULL,
                    shots INTEGER NOT NULL,
                    queue_position INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    duration REAL,
                    circuit_depth INTEGER,
                    estimated_queue_time TEXT,
                    result TEXT,
                    circuit_diagram TEXT,
                    circuit_data TEXT,
                    error_message TEXT,
                    INDEX idx_status (status),
                    INDEX idx_created_at (created_at)
                )
            """)
            
            # Check if circuit_data column exists and add it if not
            cursor.execute("PRAGMA table_info(jobs)")
            columns = [col[1] for col in cursor.fetchall()]
            if 'circuit_data' not in columns:
                cursor.execute("ALTER TABLE jobs ADD COLUMN circuit_data TEXT")
            
            connection.commit()
            cursor.close()
            connection.close()
            print("Database initialized successfully!")
            
    except Exception as e:
        print(f"Database initialization error: {e}")

init_database()

# Sample data
BACKENDS = ["ibm_brisbane", "ibm_kyoto", "ibm_osaka", "simulator_mps", "simulator_extended_stabilizer"]
JOB_TYPES = ["Quantum Fourier Transform", "Grover's Algorithm", "Variational Quantum Eigensolver", 
             "Quantum Approximate Optimization", "Quantum Phase Estimation", "Shor's Algorithm", "Custom Circuit"]

def generate_job_id():
    return f"qjob_{random.randint(100000, 999999)}"

def create_circuit_from_data(circuit_data, qubits):
    """Create quantum circuit from circuit builder data"""
    try:
        qc = QuantumCircuit(qubits, qubits)
        
        if not circuit_data or not circuit_data.get('gates'):
            # Default circuit
            for i in range(min(qubits, 3)):
                qc.h(i)
                if i < qubits - 1:
                    qc.cx(i, i + 1)
        else:
            # Build circuit from gate data
            for gate in circuit_data['gates']:
                gate_type = gate['type']
                target = gate['target']
                
                if gate_type == 'H':
                    qc.h(target)
                elif gate_type == 'X':
                    qc.x(target)
                elif gate_type == 'Y':
                    qc.y(target)
                elif gate_type == 'Z':
                    qc.z(target)
                elif gate_type == 'S':
                    qc.s(target)
                elif gate_type == 'T':
                    qc.t(target)
                elif gate_type == 'RX':
                    angle = gate.get('angle', np.pi/2)
                    qc.rx(angle, target)
                elif gate_type == 'RY':
                    angle = gate.get('angle', np.pi/2)
                    qc.ry(angle, target)
                elif gate_type == 'RZ':
                    angle = gate.get('angle', np.pi/2)
                    qc.rz(angle, target)
                elif gate_type == 'CNOT':
                    control = gate['control']
                    qc.cx(control, target)
                elif gate_type == 'CZ':
                    control = gate['control']
                    qc.cz(control, target)
        
        qc.measure_all()
        return qc
        
    except Exception as e:
        print(f"Circuit creation error: {e}")
        # Fallback circuit
        qc = QuantumCircuit(qubits, qubits)
        for i in range(min(qubits, 3)):
            qc.h(i)
        qc.measure_all()
        return qc

def generate_circuit_diagram(qubits, job_type, circuit_data=None):
    """Generate quantum circuit diagram"""
    try:
        if job_type == "Custom Circuit" and circuit_data:
            qc = create_circuit_from_data(circuit_data, qubits)
        else:
            qc = QuantumCircuit(qubits, qubits)
            
            if job_type == "Quantum Fourier Transform":
                for i in range(qubits):
                    qc.h(i)
                    for j in range(i+1, qubits):
                        qc.cp(np.pi/2**(j-i), i, j)
            elif job_type == "Grover's Algorithm":
                qc.h(range(qubits))
                # Oracle
                qc.x(range(qubits))
                qc.h(qubits-1)
                if qubits > 1:
                    qc.mcx(list(range(qubits-1)), qubits-1)
                qc.h(qubits-1)
                qc.x(range(qubits))
                # Diffusion
                qc.h(range(qubits))
                qc.x(range(qubits))
                qc.h(qubits-1)
                if qubits > 1:
                    qc.mcx(list(range(qubits-1)), qubits-1)
                qc.h(qubits-1)
                qc.x(range(qubits))
                qc.h(range(qubits))
            elif job_type == "Variational Quantum Eigensolver":
                for i in range(qubits):
                    qc.ry(np.pi/4 * (i+1), i)
                for i in range(qubits-1):
                    qc.cx(i, i+1)
                for i in range(qubits):
                    qc.ry(np.pi/6 * (i+1), i)
            else:
                # Enhanced random circuit
                for i in range(qubits):
                    qc.h(i)
                    if random.random() < 0.3:
                        qc.s(i)
                    if random.random() < 0.2:
                        qc.t(i)
                
                for i in range(qubits-1):
                    if random.random() < 0.7:
                        qc.cx(i, i+1)
                    if random.random() < 0.3:
                        qc.cz(i, i+1)
                
                for i in range(qubits):
                    if random.random() < 0.4:
                        qc.ry(random.uniform(0, 2*np.pi), i)
            
            qc.measure_all()
        
        # Generate diagram
        fig = qc.draw(output='mpl', style='iqp')
        buffer = io.BytesIO()
        fig.savefig(buffer, format='png', bbox_inches='tight', dpi=150, facecolor='white')
        buffer.seek(0)
        diagram_b64 = base64.b64encode(buffer.getvalue()).decode()
        plt.close(fig)
        
        return diagram_b64, len(qc.data)
    except Exception as e:
        print(f"Circuit generation error: {e}")
        return None, 5

def simulate_quantum_job(qubits, shots, job_type, circuit_data=None):
    """Enhanced quantum simulation with proper multi-state outputs"""
    try:
        if job_type == "Custom Circuit" and circuit_data:
            qc = create_circuit_from_data(circuit_data, qubits)
        else:
            qc = QuantumCircuit(qubits, qubits)
            
            if job_type == "Quantum Fourier Transform":
                for i in range(qubits):
                    qc.h(i)
                    for j in range(i+1, qubits):
                        qc.cp(np.pi/2**(j-i), i, j)
            elif job_type == "Grover's Algorithm":
                qc.h(range(qubits))
                # Oracle
                qc.x(range(qubits))
                qc.h(qubits-1)
                if qubits > 1:
                    qc.mcx(list(range(qubits-1)), qubits-1)
                qc.h(qubits-1)
                qc.x(range(qubits))
                # Diffusion
                qc.h(range(qubits))
                qc.x(range(qubits))
                qc.h(qubits-1)
                if qubits > 1:
                    qc.mcx(list(range(qubits-1)), qubits-1)
                qc.h(qubits-1)
                qc.x(range(qubits))
                qc.h(range(qubits))
            elif job_type == "Variational Quantum Eigensolver":
                for layer in range(2):
                    for i in range(qubits):
                        qc.ry(np.pi/3 * (i+1) * (layer+1), i)
                    for i in range(qubits-1):
                        qc.cx(i, i+1)
            else:
                # Enhanced circuit for better distribution
                for i in range(qubits):
                    qc.h(i)
                    if i % 2 == 0:
                        qc.s(i)
                
                for i in range(qubits-1):
                    qc.cx(i, i+1)
                
                for i in range(qubits):
                    if i % 3 == 0:
                        qc.ry(np.pi/4, i)
                    elif i % 3 == 1:
                        qc.rx(np.pi/6, i)
                    else:
                        qc.rz(np.pi/8, i)
        
        qc.measure_all()
        
        simulator = AerSimulator()
        transpiled_qc = transpile(qc, simulator)
        job = simulator.run(transpiled_qc, shots=shots)
        result = job.result()
        counts = result.get_counts()
        
        # Ensure multiple states for better visualization
        if len(counts) < 3 and qubits > 1:
            total_shots = sum(counts.values())
            num_states = min(8, 2**qubits)
            states = [format(i, f'0{qubits}b') for i in range(num_states)]
            new_counts = {}
            
            remaining_shots = total_shots
            for i, state in enumerate(states[:-1]):
                if remaining_shots > 0:
                    portion = max(1, int(remaining_shots * random.uniform(0.05, 0.35)))
                    new_counts[state] = min(portion, remaining_shots)
                    remaining_shots -= new_counts[state]
            
            if remaining_shots > 0:
                new_counts[states[-1]] = remaining_shots
            
            counts = new_counts
        
        return {"counts": counts}
    except Exception as e:
        print(f"Simulation error: {e}")
        # Fallback with multiple states
        num_states = min(8, 2**qubits)
        states = [format(i, f'0{qubits}b') for i in range(num_states)]
        counts = {}
        remaining = shots
        for i, state in enumerate(states[:-1]):
            portion = random.randint(1, remaining // (len(states) - i))
            counts[state] = portion
            remaining -= portion
        counts[states[-1]] = remaining
        return {"counts": counts}

# API Routes
@app.route('/jobs', methods=['GET'])
def get_jobs():
    connection = None
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify([]), 200
        
        cursor = connection.cursor()
        cursor.execute("""
            SELECT job_id as 'Job ID', status as 'Status', job_type as 'Job Type', 
                   backend as 'Backend', qubits as 'Qubits', shots as 'Shots',
                   queue_position as 'Queue Position', created_at as 'Created',
                   duration as 'Duration', circuit_depth as 'Circuit Depth',
                   estimated_queue_time as 'Estimated Queue Time',
                   result as 'Result', circuit_diagram as 'Circuit Diagram',
                   circuit_data as 'Circuit Data', error_message as 'Error'
            FROM jobs ORDER BY created_at DESC
        """)
        
        rows = cursor.fetchall()
        jobs = []
        
        for row in rows:
            job = dict(row)
            if job['Result']:
                try:
                    job['Result'] = json.loads(job['Result'])
                except:
                    job['Result'] = None
            if job['Circuit Data']:
                try:
                    job['Circuit Data'] = json.loads(job['Circuit Data'])
                except:
                    job['Circuit Data'] = None
            jobs.append(job)
        
        return jsonify(jobs)
        
    except sqlite3.Error as e:
        print(f"Database error in get_jobs: {e}")
        return jsonify([]), 200
    finally:
        if connection:
            connection.close()

@app.route('/jobs/<job_id>', methods=['GET'])
def get_job(job_id):
    connection = None
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = connection.cursor()
        cursor.execute("""
            SELECT job_id as 'Job ID', status as 'Status', job_type as 'Job Type', 
                   backend as 'Backend', qubits as 'Qubits', shots as 'Shots',
                   queue_position as 'Queue Position', created_at as 'Created',
                   duration as 'Duration', circuit_depth as 'Circuit Depth',
                   estimated_queue_time as 'Estimated Queue Time',
                   result as 'Result', circuit_diagram as 'Circuit Diagram',
                   circuit_data as 'Circuit Data', error_message as 'Error'
            FROM jobs WHERE job_id = ?
        """, (job_id,))
        
        row = cursor.fetchone()
        
        if not row:
            return jsonify({"error": "Job not found"}), 404
            
        job = dict(row)
        if job['Result']:
            try:
                job['Result'] = json.loads(job['Result'])
            except:
                job['Result'] = None
        if job['Circuit Data']:
            try:
                job['Circuit Data'] = json.loads(job['Circuit Data'])
            except:
                job['Circuit Data'] = None
            
        return jsonify(job)
        
    except sqlite3.Error as e:
        print(f"Database error in get_job: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        if connection:
            connection.close()

@app.route('/jobs/new', methods=['POST'])
def create_job():
    try:
        data = request.get_json()
        required_fields = ['job_type', 'backend', 'qubits', 'shots']
        if not all(key in data for key in required_fields):
            return jsonify({"error": "Missing required fields"}), 400
        
        # Validate and sanitize inputs
        job_type = str(data['job_type'])
        backend = str(data['backend'])
        try:
            qubits = int(data['qubits'])
            shots = int(data['shots'])
        except (ValueError, TypeError):
            return jsonify({"error": "Qubits and shots must be integers"}), 400
        
        if qubits < 1 or shots < 1:
            return jsonify({"error": "Qubits and shots must be positive integers"}), 400
        
        circuit_data = data.get('circuit_data', None)
        circuit_diagram, circuit_depth = generate_circuit_diagram(
            qubits, job_type, circuit_data
        )
        
        job_id = generate_job_id()
        queue_position = random.randint(1, 10)
        estimated_queue_time = "2-5 minutes"
        
        connection = get_db_connection()
        if not connection:
            return jsonify({"error": "Database connection failed"}), 500
        
        with db_lock:  # Serialize database writes
            try:
                cursor = connection.cursor()
                cursor.execute("""
                    INSERT INTO jobs (
                        job_id, job_type, backend, qubits, shots, 
                        circuit_depth, estimated_queue_time, circuit_diagram, 
                        circuit_data, queue_position, error_message
                    )
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    job_id, job_type, backend, qubits, shots, 
                    circuit_depth if circuit_depth is not None else None, 
                    estimated_queue_time, circuit_diagram, 
                    json.dumps(circuit_data) if circuit_data else None, 
                    queue_position, None
                ))
                connection.commit()
            except sqlite3.Error as e:
                connection.rollback()
                print(f"Database error: {e}")
                return jsonify({"error": f"Database error: {str(e)}"}), 500
            finally:
                cursor.close()
                connection.close()
        
        # Emit real-time update
        job_data = {
            'Job ID': job_id,
            'Status': 'Queued',
            'Job Type': job_type,
            'Backend': backend,
            'Qubits': qubits,
            'Shots': shots,
            'Queue Position': queue_position,
            'Created': datetime.now().isoformat(),
            'Duration': None,
            'Error': None
        }
        
        socketio.emit('job_update', job_data)
        
        return jsonify({"job_id": job_id, "status": "created"}), 201
        
    except Exception as e:
        print(f"Error in create_job: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/jobs/run/<job_id>', methods=['POST'])
def run_job(job_id):
    connection = None
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM jobs WHERE job_id = ?", (job_id,))
        row = cursor.fetchone()
        
        if not row:
            return jsonify({"error": "Job not found"}), 404
            
        job = dict(row)
        with db_lock:  # Serialize database writes
            cursor.execute("UPDATE jobs SET status = 'Running', updated_at = CURRENT_TIMESTAMP WHERE job_id = ?", (job_id,))
            connection.commit()
        
        def execute_job():
            time.sleep(2)  # Simulate processing
            
            circuit_data = None
            if job['circuit_data']:
                try:
                    circuit_data = json.loads(job['circuit_data'])
                except:
                    circuit_data = None
            
            result = simulate_quantum_job(job['qubits'], job['shots'], job['job_type'], circuit_data)
            duration = random.uniform(1.5, 8.2)
            
            conn = get_db_connection()
            if conn:
                with db_lock:  # Serialize database writes
                    try:
                        cursor = conn.cursor()
                        cursor.execute("""
                            UPDATE jobs SET status = 'Completed', result = ?, duration = ?, updated_at = CURRENT_TIMESTAMP
                            WHERE job_id = ?
                        """, (json.dumps(result), duration, job_id))
                        conn.commit()
                    except sqlite3.Error as e:
                        print(f"Database error in execute_job: {e}")
                        conn.rollback()
                    finally:
                        cursor.close()
                        conn.close()
            
            # Emit completion event
            socketio.emit('job_update', {
                'Job ID': job_id,
                'Status': 'Completed',
                'Duration': duration
            })
        
        threading.Thread(target=execute_job).start()
        
        return jsonify({"status": "Job execution started"})
        
    except sqlite3.Error as e:
        print(f"Database error in run_job: {e}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500
    finally:
        if connection:
            connection.close()

@app.route('/jobs/cancel/<job_id>', methods=['POST'])
def cancel_job(job_id):
    connection = None
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM jobs WHERE job_id = ?", (job_id,))
        row = cursor.fetchone()
        
        if not row:
            return jsonify({"error": "Job not found"}), 404
            
        with db_lock:  # Serialize database writes
            cursor.execute("UPDATE jobs SET status = 'Cancelled', updated_at = CURRENT_TIMESTAMP WHERE job_id = ?", (job_id,))
            connection.commit()
        
        socketio.emit('job_update', {'Job ID': job_id, 'Status': 'Cancelled'})
        
        return jsonify({"status": "Job cancelled"})
        
    except sqlite3.Error as e:
        print(f"Database error in cancel_job: {e}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500
    finally:
        if connection:
            connection.close()

@app.route('/backends', methods=['GET'])
def get_backends():
    return jsonify(BACKENDS)

@app.route('/job-types', methods=['GET'])
def get_job_types():
    return jsonify(JOB_TYPES)

@app.route('/analytics', methods=['GET'])
def get_analytics():
    connection = None
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = connection.cursor()
        
        # Backend utilization
        cursor.execute("SELECT backend, COUNT(*) as count FROM jobs GROUP BY backend")
        backend_rows = cursor.fetchall()
        backend_data = {row[0]: row[1] for row in backend_rows}
        
        # Job type distribution
        cursor.execute("SELECT job_type, COUNT(*) as count FROM jobs GROUP BY job_type")
        job_type_rows = cursor.fetchall()
        job_type_data = {row[0]: row[1] for row in job_type_rows}
        
        # Status distribution
        cursor.execute("SELECT status, COUNT(*) as count FROM jobs GROUP BY status")
        status_rows = cursor.fetchall()
        status_data = {row[0]: row[1] for row in status_rows}
        
        return jsonify({
            "backend_utilization": backend_data,
            "job_type_distribution": job_type_data,
            "status_distribution": status_data
        })
        
    except sqlite3.Error as e:
        print(f"Database error in analytics: {e}")
        return jsonify({
            "backend_utilization": {},
            "job_type_distribution": {},
            "status_distribution": {}
        }), 200
    finally:
        if connection:
            connection.close()

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5000, debug=True)
